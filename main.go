package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
	"sync"
)

// Location represents a location with latitude, longitude and elevation
type Location struct {
	Lat  float64
	Lon  float64
	Elev int
}

// CtoF converts temperature in Celsius to Fahrenheit
func CtoF(temp float64) float64 {
	return temp*9/5 + 32
}

// FtoC converts temperature in Fahrenheit to Celsius
func FtoC(temp float64) float64 {
	return (temp - 32) * 5 / 9
}

// parseLocation parses location from strings into Location struct
func parseLocation(latS string, lonS string, elevS string) (loc Location, err error) {
	// Lat
	if len(latS) > 0 { // only for non-empty string
		fields := strings.Fields(latS)
		if len(fields) == 2 {
			// Convert degrees
			deg, err := strconv.Atoi(fields[0])
			if err != nil {
				return Location{}, err
			}

			// Convert the rest
			rest, err := strconv.ParseFloat(fields[1], 64)
			if err != nil {
				return Location{}, err
			}

			loc.Lat = float64(deg) + rest
		}
	}

	// Lon
	if len(lonS) > 0 { // only for non-empty string
		fields := strings.Fields(lonS)
		if len(fields) == 2 {
			// Convert degrees
			deg, err := strconv.Atoi(fields[0])
			if err != nil {
				return Location{}, err
			}

			// Convert the rest
			rest, err := strconv.ParseFloat(fields[1], 64)
			if err != nil {
				return Location{}, err
			}

			loc.Lon = float64(deg) + rest
		}
	}

	// Elv
	if len(elevS) > 0 { // only for non-empty string
		loc.Elev, err = strconv.Atoi(elevS)
		if err != nil {
			return Location{}, err
		}
	}

	return loc, nil
}

func parseFile(path string) []*DataLine {
	file, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	cr := csv.NewReader(file)

	datalines := []*DataLine{}

	firstLine := true
	for {
		fields, err := cr.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}

		if !firstLine { // Discard first line, as it's headers, not data
			line := &DataLine{}
			if err = line.Marshal(fields); err != nil {
				log.Panicf("File: %s\nError: %#v\n", path, err)
			}

			datalines = append(datalines, line)

		} else {
			firstLine = false
		}
	}

	return datalines
}

func parseFileGo(wg *sync.WaitGroup, out chan []*DataLine, path string) {
	defer wg.Done()

	out <- parseFile(path)
}

// DataFile represents CSV file with data
type DataFile struct {
	Name  string
	Lines []*DataLine
}

func printHelp() {
	fmt.Println("leafspycsv is a tool for parsing CSV files generated by LeafSpy")
	fmt.Println()
	fmt.Println("")
}

func main() {
	args := os.Args[1:]
	if len(args) == 0 {
		fmt.Println("go-leafspycsv: Error. No input files. See go-leafspycsv help for more info.")
		os.Exit(1)
	}

	if len(args) == 1 {
		if strings.ToLower(args[0]) == "help" {
			printHelp()
			os.Exit(0)
		}
	}

	datafiles := []DataFile{}

	for i := 0; i < len(args); i++ {
		fi, err := os.Stat(args[i])
		if err != nil {
			if os.IsNotExist(err) {
				fmt.Printf("%s does not exist. Quitting.", args[i])
			} else {
				log.Fatal(err)
			}
		}

		if fi.IsDir() {
			// Read files in directory
			files, err := ioutil.ReadDir(args[i])
			if err != nil {
				log.Fatalf("File %s does not exist.", args[i])
				panic(err)
			}

			// Concurrently parse CSV files
			var wg sync.WaitGroup
			lines := make(chan []*DataLine, len(files))
			wg.Add(len(files))
			for _, file := range files {
				go parseFileGo(&wg, lines, args[i]+"/"+file.Name())
			}

			wg.Wait()
			close(lines)

			for line := range lines {
				datafile := DataFile{fi.Name(), line}
				datafiles = append(datafiles, datafile)
			}

		} else {
			// Single file
			datafile := DataFile{fi.Name(), parseFile(fi.Name())}
			datafiles = append(datafiles, datafile)
		}

		count := 0
		for _, df := range datafiles {
			count += len(df.Lines)
		}

		fmt.Printf("Number of files: %d\n", len(datafiles))
		fmt.Printf("Number of lines total: %d\n", count)
	}
}
